<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Callback Functions</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="Doc-O-Matic" />
    <meta name="save" content="history" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <link rel="STYLESHEET" href="default.css" type="text/css" />

<script type="text/javascript" src="scripts.js"></script>
</head>
<body class="Element700" onload="onBodyLoad();" onmousedown="onBodyMouseDown();">
<div id="persistenceDiv" style="display:none; behavior:url(#default#userData);"></div>

<!-- Begin Popups -->

<!-- End Popups -->

<!-- Begin Page Header -->
<div class="Element710" id="areafixed">
<div class="Element94">
<a href="13064.html">Volume IV: MPLAB Harmony Development</a> &gt; <a href="16810.html">MPLAB Harmony Driver Development Guide</a> &gt; <a href="11784.html">Interrupt and Thread Safety</a> &gt; <a href="11770.html">Callback Functions</a></div>
<div class="Element92">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="25%">
<div class="Element1">
MPLAB Harmony Help</div>
</td><td width="25%">
<div class="Element2">
<a href="contents.htm">Contents</a> | <a href="idx.html">Index</a> | <a href="04300.html">Home</a></div>
</td><td width="25%">
<div class="Element90">
<a href="11798.html">Previous</a> | <a href="11784.html">Up</a> | <a href="11803.html">Next</a></div>
</td><td width="25%">
<div class="Element96">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: DRVDEVGUIDE Callback Functions Topic Title: Callback Functions)&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com">Microchip Support</a></div>
</td></tr></table><div class="Element5">
Callback Functions</div>
</div>
</div>

<!-- End Page Header -->

<!-- Begin Client Area -->
<div class="Element720" id="areascroll">
<div class="Element721">

<!-- Begin Page Content -->
<div class="Element58">
<a name="4465736372697074696F6E"></a><div class="Element11">
<div class="Element10">
<p class="Element10">
Normally, a client calls the driver’s interface functions to interact with it. But, a callback function is a client function called by the driver back to the client, instead of the other way around, as shown in the following diagram. </p><p class="Element10" style="text-align: center;">
<strong>Callback Functions</strong>&nbsp;</p>
<p class="Element10" style="text-align: center;">
<img src="DRVDEVGUIDE Callback Functions.png" border="0" alt="" title=""></p><p class="Element10">
Callback functions are usually dynamically registered with a driver (or other server library). To do this, the driver provides an interface function that the client can call and pass in a pointer to the function it wants the driver to call back (the MyCallback function in the following example).&nbsp;</p>
<p class="Element10">
<strong>Example: Registering a Callback Function</strong> &nbsp;</p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code00152');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code00152"><pre class="Element12"><strong><span style="color: #000080">#define</span></strong> PERIOD    1000
<strong><span style="color: #000080">#define</span></strong> NO_REPEAT <strong><span style="color: #000080">false</span></strong>

<strong><span style="color: #000080">if</span></strong> (DRV_TMR_AlarmRegister(pObj-&gt;tmrHandle, PERIOD, NO_REPEAT, pObj, MyCallback))
{
    <i><span style="color: #008000">/* Successfully registered “MyCallback” function */</span></i>
}</pre></div></div>
<p class="Element10">
A callback is different from functions that are statically linked and called from the driver by name. Statically linked functions are considered dependencies. Dependencies are requirements of the driver. It will not build without an implementation of the dependency. Dependencies should be limited to only the things that the driver needs to use to do its job. They should not be part of the client interface. If they are, they force the driver to be static and single client. Dynamically registering a callback function (by a function pointer) instead of statically linking it to the driver allows the driver to be static or dynamic, or single client or multiple client. </p><div class="Element63">
<div class="TableDiv">
<table cellspacing="0" class="Table0">
<tr>
<td class="Element67" valign="top" width="10%" style="border:none;">
<div class="Element68">
<img src="Note Icon.png" border="0" alt="" title=""> <strong>Note:</strong>&nbsp;</div></td><td class="Element67" valign="top" width="90%" style="border:none;">
<div class="Element68">
Sometimes two libraries may be mutually dependent on each other or a library may have dependencies upon functions defined in configuration files that are implemented as part of the system configuration. But, a library should not be dependent upon a client.&nbsp;</div></td></tr></table></div></div>
<p class="Element10">
The callback function whose address is passed to the callback registration function probably needs to do something when it is called back. Likely it will need to set a flag (or semaphore) or capture some status value (see the following example).&nbsp;</p>
<p class="Element10">
<strong>Example: Callback Function</strong> &nbsp;</p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code00153');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code00153"><pre class="Element12"><strong><span style="color: #000080">void</span></strong> MyCallback ( uintptr_t context, uint32_t alarmCount )
{
    MY_DATA_OBJECT *pObj = (MY_DATA_OBJECT *)context;

    pObj-&gt;alarmCount += alarmCount;
}</pre></div></div>
<p class="Element10">
Caution should be taken when designing the usage model of a driver callback. This is because in an interrupt-driven configuration the callback function might be called from the driver’s ISR or in a RTOS configuration the callback might be called from a different thread context. This places additional complexity on the client and on the driver, especially if the client then needs to call the driver’s interface functions from the callback function.&nbsp;</p>
<p class="Element10">
Also, it is important to carefully document the context in which a callback function can be called because a client cannot disable an interrupt owned by a driver, or any other module, because each module manages its own interrupts. It would be a violation of the driver’s abstraction. The client should not know what interrupts the driver uses or if it uses any interrupts at all. In this situation, a client may not be able to make non-atomic accesses to its own internal data structures if they are accessed by the callback and its own state machine or interface functions without globally disabling interrupts. For example, the <span class="Element146">pObj-&gt;alarmCount += alarmCount</span> line in the previous example is a non-atomic (read-modify-write) access so the client using this driver would need to stop the timer callbacks from happening before it attempted to perform a non-atomic access to the <span class="Element146">alarmCount</span> variable in its MY_DATA_OBJECT structure from any of its other functions, as shown in the following example.&nbsp;</p>
<p class="Element10">
<strong>Example: Temporarily Disabling a Callback</strong> &nbsp;</p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code00154');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code00154"><pre class="Element12"><strong><span style="color: #000080">bool</span></strong> previousAlarmEnable;

alarmWasDisabled = DRV_TMR_AlarmDisable(pObj-&gt;myTimer);

<strong><span style="color: #000080">if</span></strong> (pObj-&gt;alarmCount &gt; MY_MAX_ALARM_COUNT)
{
    <i><span style="color: #008000">/* Reset my alarm count. */</span></i>
    pObj-&gt;alarmCount = 0;
}

DRV_TMR_AlarmEnable(pObj-&gt;myTimer, previousAlarmEnable);</pre></div></div>
<p class="Element10">
In the previous example, the <span class="Element146">if</span> statement reads the <span class="Element146">alarmCount</span> member of the current module’s structure and, depending on its value, the assignment inside the <span class="Element146">if</span> statement modifies and writes it. Since this takes more than one instruction, the caller cannot allow alarm callbacks to occur in this time. So, the Timer Driver provides client interface functions to conveniently disable and restore the callback functionality. If the driver did not provide these functions the client would have to deregister the callback and/or stop the timer to ensure that the <span class="Element146">alarmCount</span> variable would not be corrupted by a simultaneous access by its own interface or tasks functions.&nbsp;</p>
<p class="Element10">
Another concern that the driver developer must take care to avoid when providing a callback function is a common race condition that can occur. Most callback functions are used as synchronization methods. (See <a href="11803.html">Synchronization</a> for details.) An interface call-in function will usually start some process that takes time and a callback function will notify the client when the process has completed. The danger is that, if the process completes too quickly, it may cause an interrupt to occur immediately and call the callback function before the call-in function returns. That can be a serious problem if the client needs to use the return value of the interface call-in function from within the callback function. Unfortunately, that is exactly what would happen when a transfer handle is returned from a data transfer function, as shown in the following example.&nbsp;</p>
<p class="Element10">
<strong>Example: Transfer Synchronization Callback</strong> &nbsp;</p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code00155');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code00155"><pre class="Element12"><strong><span style="color: #000080">void</span></strong> MyBufferEventHandler ( DRV_USART_BUFFER_EVENT  event,
                            DRV_USART_BUFFER_HANDLE bufferHandle,
                            uintptr_t               context )
{
    MY_OBJ *pObj = (MY_OBJ *)context;

    <strong><span style="color: #000080">if</span></strong> (pObj-&gt;myBufferHandle == bufferHandle)
    {
        <strong><span style="color: #000080">switch</span></strong>(event)
        {
            <strong><span style="color: #000080">case</span></strong> DRV_USART_BUFFER_EVENT_COMPLETE:
            {
                <i><span style="color: #008000">/* Clean up after my buffer transfer is complete. */</span></i>
            }

            <i><span style="color: #008000">/* Handle other events for my buffer */</span></i>
        }
    }
}</pre></div></div>
<p class="Element10">
<strong>Example: Interface With an Intrinsic Race Condition</strong> </p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code00156');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code00156"><pre class="Element12"><strong><span style="color: #000080">char</span></strong> buffer[] = “Hello World\n”;

pObj-&gt;bufferHandle = DRV_USART_BufferAddWrite(pObj-&gt;myUsart, buffer, strlen(buffer));</pre></div></div>
<p class="Element10">
In the previous example, the <a href="11475.html">DRV_USART_BufferAddWrite</a> function adds the buffer containing the <span class="Element146">Hello World\n</span> string to the USART driver’s write buffer queue and returns a handle identifying the request to write that buffer. When the transfer completes, the driver will call the MyBufferEventHandler function and pass in the DRV_USART_BUFFER_EVENT_COMPLETE event, the buffer handle returned from the <a href="11475.html">DRV_USART_BufferAddWrite</a> function, and the context value passed in when the callback was registered. (The context is used to identify the instance of the caller that registered the callback. In most cases, a caller will pass in a pointer to its instance data structure so the callback can recover it, as shown in this example.)&nbsp;</p>
<p class="Element10">
In this example, as long as the <a href="11475.html">DRV_USART_BufferAddWrite</a> function returns the buffer handle before transfer finishes and the MyBufferEventHandler function is called back, this will work just fine. But, what happens if the write queue is empty, the buffer is only one byte in size and the baud rate really is high? It is possible that the transfer will finish and the callback will happen when the interrupt occurs before the <a href="11475.html">DRV_USART_BufferAddWrite</a> function has had time to return and the buffer handle value has been assigned to the <span class="Element146">pObj-&gt;bufferHandle</span> variable. If that should happen, the value of the <span class="Element146">bufferHandle</span> parameter passed into the MyBufferEventHandler callback function will not match the value in the value stored in the <span class="Element146">pObj-&gt;bufferHandle</span> variable because it has not yet been stored there. When that occurs, the MyBufferEventHandler function will incorrectly decide that the event was not for buffer it was looking for and it will not correctly perform whatever clean-up logic it was designed to perform. So, whether or not this callback works correctly depends on who wins the race, the client or the driver.&nbsp;</p>
<p class="Element10">
To avoid this common race condition, it is necessary to put the timing of the assignment of the buffer handle into the hands of the driver where it can be managed successfully. A better driver interface design would make the transfer handle an output parameter instead of a return value by passing the address of the variable to receive the value of the buffer handle as a parameter, as shown in the following example.&nbsp;</p>
<p class="Element10">
<strong>Example: Interface Without an Intrinsic Race Condition</strong> &nbsp;</p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code00157');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code00157"><pre class="Element12"><strong><span style="color: #000080">char</span></strong> buffer[] = “Hello World\n”;

DRV_USART_BufferAddWrite(pObj-&gt;myUsart, buffer, strlen(buffer), &amp;pObj-&gt;bufferHandle);</pre></div></div>
<p class="Element10">
In this example, the USART driver can now eliminate the potential race condition that was intrinsic in the previous <a href="11475.html">DRV_USART_BufferAddWrite</a> and callback interface. By passing the address of the <span class="Element146">pObj-&gt;bufferHandle</span> variable into the <a href="11475.html">DRV_USART_BufferAddWrite</a> function, the driver can ensure that it assigns the correct <span class="Element146">buffer</span> handle value to the variable before it starts transferring the buffer. This guarantees that, no matter how quickly the buffer transfer finishes and how quickly the callback occurs, the client’s variable has the correct value so it will match the value passed in by the driver.&nbsp;</p>
<p class="Element10">
Callback functions can be a very useful mechanism for synchronizing between a driver and its client, but care must be taken make sure the client has a working usage model or the driver may not be useful in some configurations.</p></div>
</div>
</div>
<!-- End Page Content -->

<!-- Begin Page Footer -->
<div class="Element95">
<a href="13064.html">Volume IV: MPLAB Harmony Development</a> &gt; <a href="16810.html">MPLAB Harmony Driver Development Guide</a> &gt; <a href="11784.html">Interrupt and Thread Safety</a> &gt; <a href="11770.html">Callback Functions</a></div>
<div class="Element93">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="100%">
<div class="Element3">
 MPLAB Harmony Help</div>
</td></tr><tr><td width="100%">
<div class="Element4">
<a href="contents.htm">Contents</a> | <a href="idx.html">Index</a> | <a href="04300.html">Home</a></div>
</td></tr><tr><td width="100%">
<div class="Element97">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: DRVDEVGUIDE Callback Functions Topic Title: Callback Functions)&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com">Microchip Support</a></div>
</td></tr></table></div>

<!-- End Page Footer -->
</div>
</div>

<!-- End Client Area -->
</body></html>