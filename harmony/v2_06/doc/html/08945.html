<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>How the Library Works</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="Doc-O-Matic" />
    <meta name="save" content="history" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <link rel="STYLESHEET" href="default.css" type="text/css" />

<script type="text/javascript" src="scripts.js"></script>
</head>
<body class="Element700" onload="onBodyLoad();" onmousedown="onBodyMouseDown();">
<div id="persistenceDiv" style="display:none; behavior:url(#default#userData);"></div>

<!-- Begin Popups -->

<!-- End Popups -->

<!-- Begin Page Header -->
<div class="Element710" id="areafixed">
<div class="Element94">
<a href="16811.html">Volume V: MPLAB Harmony Framework Reference</a> &gt; <a href="13069.html">Driver Libraries Help</a> &gt; <a href="28590.html">USB Driver Libraries</a> &gt; <a href="08950.html">PIC32MZ USB Driver</a> &gt; <a href="08951.html">Using the Library</a> &gt; <a href="08945.html">How the Library Works</a></div>
<div class="Element92">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="25%">
<div class="Element1">
MPLAB Harmony Help</div>
</td><td width="25%">
<div class="Element2">
<a href="contents.htm">Contents</a> | <a href="idx.html">Index</a> | <a href="04300.html">Home</a></div>
</td><td width="25%">
<div class="Element90">
<a href="08937.html">Previous</a> | <a href="08951.html">Up</a> | <a href="08940.html">Next</a></div>
</td><td width="25%">
<div class="Element96">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: DRV USB PIC32MZ How the Library Works Topic Title: How the Library Works)&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com">Microchip Support</a></div>
</td></tr></table><div class="Element5">
How the Library Works</div>
</div>
</div>

<!-- End Page Header -->

<!-- Begin Client Area -->
<div class="Element720" id="areascroll">
<div class="Element721">

<!-- Begin Page Content -->
<div class="Element58">
<a name="4465736372697074696F6E"></a><div class="Element11">
<div class="Element10">
<p class="Element10">
This section only explains aspects of driver operation which are unique to the PIC32MZ USB Driver. Major driver operations are described in the PIC32 USB Driver <a href="08911.html">Common Interface</a> help section.</p><div class="Element15">
Driver Initialization</div>
<div class="Element63">
<div class="TableDiv">
<table cellspacing="0" class="Table0">
<tr>
<td class="Element67" valign="top" width="10%" style="border:none;">
<div class="Element68">
<img src="Note Icon.png" border="0" alt="" title=""> <strong>Note:</strong>&nbsp;</div></td><td class="Element67" valign="top" width="90%" style="border:none;">
<div class="Element68">
While generating a MPLAB Harmony USB project with MHC, the initialization code for the driver is generated automatically based on selections made in the USB Host stack or Device Stack Configuration trees.&nbsp;</div></td></tr></table></div></div>
<p class="Element10">
The PIC32MZ USB Driver must be initialized so that a client application can open. The client application will not be able to open the driver if the initialization is in progress or has failed. The driver is initialized by calling the <a href="11689.html">DRV_USBHS_Initialize</a> function. This function is called from the <a href="23925.html">SYS_Initialize</a> function in the MPLAB Harmony application project and accepts two input parameters. The <span class="Element146">index</span> parameter defines the instance of the USB Driver to be initialized. This becomes significant when the PIC32MZ microcontroller has more than one USB module. The <span class="Element146">init</span> parameter is a driver-specific data structure of the type <a href="11675.html">DRV_USBHS_INIT</a>. This structure is shown in the following code example. </p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code01129');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code01129"><pre class="Element12"><i><span style="color: #008000">/* This code show the PIC32MZ USB Driver Initialization data structure.
 * A structure of this type must be provided to the DRV_USBHS_Initialize
 * function. */</span></i>

<strong><span style="color: #000080">typedef</span></strong> <strong><span style="color: #000080">struct</span></strong>
{
    <i><span style="color: #008000">/* System Module Initialization */</span></i>
    SYS_MODULE_INIT moduleInit;

    <i><span style="color: #008000">/* Identifies the USB peripheral to be used. This should be the USB PLIB
       module instance identifier. */</span></i>
    uint8_t usbID;

    <i><span style="color: #008000">/* This should be set to true if the USB module must stop operation in Idle
       mode */</span></i>
    <strong><span style="color: #000080">bool</span></strong> stopInIdle;

    <i><span style="color: #008000">/* This should be set to true if the USB module must suspend when the CPU
       enters Sleep mode. */</span></i>
    <strong><span style="color: #000080">bool</span></strong> suspendInSleep;

    <i><span style="color: #008000">/* Specify the interrupt source for the USB module. This should be Interrupt
       PLIB Interrupt source identifier for the USB module instance specified in
       usbID. */</span></i>
    INT_SOURCE interruptSource;

    <i><span style="color: #008000">/* Specify the interrupt source for the USB module specific DMA controller.
     * This should be the PLIB Interrupt source identified for the USB
     * module instance specified in usbID. */</span></i>
    INT_SOURCE interruptSourceUSBDma;

    <i><span style="color: #008000">/* Specify the operational speed of the USB module. This should always be
       set to USB_SPEED_FULL. */</span></i>
    USB_SPEED operationSpeed;

    <i><span style="color: #008000">/* Specify the operation mode of the USB module. This defines if the USB
     * module will support Device, Host or Dual Role operation */</span></i>
    DRV_USBHS_OPMODES operationMode;

    <i><span style="color: #008000">/* A pointer to the endpoint descriptor table. This should be aligned at 512
       byte address boundary. The size of the table is equal to the
       DRV_USBHS_ENDPOINT_TABLE_ENTRY_SIZE times the number of endpoints needed
       in the application. */</span></i>
    <strong><span style="color: #000080">void</span></strong> * endpointTable;

    <i><span style="color: #008000">/* Root hub available current in mA. This specifies the amount of current
       that root hub can provide to the attached device. This should be
       specified in mA. This is required when the driver is required to operate
       in host mode. */</span></i>
    uint32_t rootHubAvailableCurrent;

    <i><span style="color: #008000">/* When operating in Host mode, the application can specify a Root Hub port
       enable function. This parameter should point to Root Hub port enable
       function. If this parameter is NULL, it implies that the Port is always
       enabled. */</span></i>
    DRV_USBHS_ROOT_HUB_PORT_POWER_ENABLE portPowerEnable;

    <i><span style="color: #008000">/* When operating in Host mode, the application can specify a Root Port
       Indication. This parameter should point to the Root Port Indication
       function. If this parameter is NULL, it implies that Root Port Indication
       is not supported. */</span></i>
    DRV_USBHS_ROOT_HUB_PORT_INDICATION portIndication;

    <i><span style="color: #008000">/* When operating is Host mode, the application can specify a Root Port
       Overcurrent detection. This parameter should point to the Root Port
       Indication function. If this parameter is NULL, it implies that
       Overcurrent detection is not supported. */</span></i>
    DRV_USBHS_ROOT_HUB_PORT_OVER_CURRENT_DETECT portOverCurrentDetect;

} DRV_USBHS_INIT;
</pre></div></div>
<p class="Element10">
The operationMode parameter defines the driver operation mode. This can be set to DRV_USBFS_OPMODE_DEVICE, DRV_USBFS_OPMODE_HOST, or DRV_USBFS_OPMODE_DUAL_ROLE for Device, Host and Dual Role operation, respectively.&nbsp;</p>
<p class="Element10">
The <span class="Element146">rootHubAvailableCurrent</span> parameter should be set to the maximum current that the VBUS power supply can provide on the bus. The driver does not use this information directly. It provides this data to the client application while operating in Host mode.&nbsp;</p>
<p class="Element10">
The <span class="Element146">portPowerEnable</span> parameter must point to a Port Power Enable function. The driver, while operating in Host mode, will call this function to enable the VBUS switch. This function should activate the VBUS switch if the driver calls this function with the enable parameter set to true. It should deactivate the switch if the driver calls this function with the <span class="Element146">enable</span> parameter set to false. This parameter should be set to NULL if such a switch (of the switch control) is not available in the application.&nbsp;</p>
<p class="Element10">
The <span class="Element146">portIndication</span> parameter must point to a Port Indication function. The driver, while operating in Host mode, will call this function to indicate the current state of the port. The driver will call this function with LED color status as defined in Chapter 11 of the USB 2.0 Specification. This parameter should be set to NULL if such a LED indication is not available in the application.&nbsp;</p>
<p class="Element10">
The <span class="Element146">portOverCurrentDetect</span> parameter must point to a Port Overcurrent Detect function. The driver, while operating in Host mode, will call this function periodically to check if the attached device is overdrawing current. If the function should return true if such a condition exists. This parameter should be set to NULL if such detection is not available in the application.&nbsp;</p>
<p class="Element10">
The following code example shows initialization of the driver for Device mode operation. </p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code01130');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code01130"><pre class="Element12"><i><span style="color: #008000">/* This code shows an example of DRV_USBHS_INIT data structure for
 * Device mode operation. Here the driver is initialized to work with USB0 USB
 * module. */</span></i>

DRV_USBHS_INIT init;
SYS_MODULE_OBJ usbDriverObj;

<strong><span style="color: #000080">const</span></strong> DRV_USBHS_INIT drvUSBInit =
{
    <i><span style="color: #008000">/* Interrupt Source for USB module */</span></i>
    .interruptSource = INT_SOURCE_USB_1,

    <i><span style="color: #008000">/* DMA Interrupt Source for USB module */</span></i>
    .interruptSourceUSBDma = INT_SOURCE_USB_1_DMA,

    <i><span style="color: #008000">/* System module initialization */</span></i>
    .moduleInit = {SYS_MODULE_POWER_RUN_FULL},

    <i><span style="color: #008000">/* Module operate in device mode */</span></i>
    .operationMode = DRV_USBHS_OPMODE_DEVICE,

    <i><span style="color: #008000">/* Module operated at high speed */</span></i>
    .operationSpeed = USB_SPEED_HIGH,

    <i><span style="color: #008000">/* Stop in idle */</span></i>
    .stopInIdle = <strong><span style="color: #000080">false</span></strong>,

    <i><span style="color: #008000">/* Suspend in sleep */</span></i>
    .suspendInSleep = <strong><span style="color: #000080">false</span></strong>,

    <i><span style="color: #008000">/* Identifies peripheral (PLIB-level) ID */</span></i>
    .usbID = USBHS_ID_0
};

<strong><span style="color: #000080">void</span></strong> SYS_Initialize(<strong><span style="color: #000080">void</span></strong>)
{
    <i><span style="color: #008000">/* Initialize the USB Driver. Note how the init parameter is typecast to
     * SYS_MODULE_INIT type. The SYS_MODULE_OBJ returned by this function call
     * is passed to the driver tasks routine. DRV_USBHS_INDEX_0 is helper
     * constant defined in drv_usbfs.h */</span></i>

    usbDriverObj = DRV_USBHS_Initialize(DRV_USBHS_INDEX_0, (SYS_MODULE_INIT *)(drvUSBInit));
}

<strong><span style="color: #000080">void</span></strong> SYS_Tasks(<strong><span style="color: #000080">void</span></strong>)
{
    <i><span style="color: #008000">/* The polled state of the USB driver is updated by calling the
     * DRV_USBHS_Tasks function in the SYS_Tasks() function. The
     * DRV_USBHS_Tasks() takes the driver module object returned by the
     * DRV_USBHS_Initialize funciton as a parameter. */</span></i>

    DRV_USBHS_Tasks(usbDriverObj);
}

<strong><span style="color: #000080">void</span></strong> __ISR(_USB_VECTOR, ipl4AUTO) _IntHandlerUSBInstance0(<strong><span style="color: #000080">void</span></strong>)
{
    <i><span style="color: #008000">/* The DRV_USBHS_Tasks_ISR function update the interrupt state of the USB
     * Driver. If the driver is configured for Polling mode, this function need
     * not be invoked or included in the project. */</span></i>

    DRV_USBHS_Tasks_ISR(usbDriverObj);
}

<strong><span style="color: #000080">void</span></strong> __ISR ( _USB_DMA_VECTOR,ipl4AUTO) _IntHandlerUSBInstance0_USBDMA ( <strong><span style="color: #000080">void</span></strong> )
{
    DRV_USBHS_Tasks_ISR_USBDMA(usbDriverObj);
}

</pre></div></div>
<p class="Element10">
The following code example shows initialization of the driver for Host mode operation. </p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code01131');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code01131"><pre class="Element12"><i><span style="color: #008000">/* This code shows an example of how the Hi-Speed USB (USBHS) driver can be configured
 * for Host mode operation. In this example, the
 * BSP_USBVBUSSwitchOverCurrentDetect function checks for over current condition
 * and the BSP_USBVBUSPowerEnable function enables the VBUS power. The port
 * indication function is not implemented and hence the portIndication member of
 * the initialization data structure is set to NULL. */</span></i>

<i><span style="color: #008000">/* The implementation of the port over current detect, indication and the VBUS
 * power supply functions is discussed later in this help section. */</span></i>

DRV_USBHS_INIT drvUSBHSInit =
{
    <i><span style="color: #008000">/* This should always be set to SYS_MODULE_POWER_RUN_FULL. */</span></i>
    .moduleInit = {SYS_MODULE_POWER_RUN_FULL},

    <i><span style="color: #008000">/* Interrupt Source for the USB module */</span></i>
    .interruptSource = INT_SOURCE_USB_1,

    <i><span style="color: #008000">/* Interrupt Source for the USB DMA module */</span></i>
    .interruptSourceUSBDma = INT_SOURCE_USB_1_DMA,

    <i><span style="color: #008000">/* Configure for host mode operation. */</span></i>
    .operationMode = DRV_USBHS_OPMODE_HOST,

    <i><span style="color: #008000">/* The driver should run at high speed. */</span></i>
    .operationSpeed = USB_SPEED_HIGH,

    <i><span style="color: #008000">/* Port indication function is not implemented and is not available */</span></i>
    .portIndication = NULL,

    <i><span style="color: #008000">/* This is the VBUS Power enable function */</span></i>
    .portPowerEnable = BSP_USBVBUSPowerEnable,

    <i><span style="color: #008000">/* This is the over current detect function. */</span></i>
    .portOverCurrentDetect = BSP_USBVBUSSwitchOverCurrentDetect,

    <i><span style="color: #008000">/* Here we state that the VBUS power supply can provide at most 500 mA of
     * current */</span></i>
    .rootHubAvailableCurrent = 500,

    <i><span style="color: #008000">/* Moudule will operate in IDLE. */</span></i>
    .stopInIdle = <strong><span style="color: #000080">false</span></strong>,

    <i><span style="color: #008000">/* Module will not suspend automatically in sleep */</span></i>
    .suspendInSleep = <strong><span style="color: #000080">false</span></strong>,

    <i><span style="color: #008000">/* USB Module ID is 1 */</span></i>
    .usbID = USBHS_ID_0

};

<strong><span style="color: #000080">void</span></strong> SYS_Initialize(<strong><span style="color: #000080">void</span></strong>)
{
    <i><span style="color: #008000">/* Initialize the USB Driver. Note how the init parameter is typecast to
     * SYS_MODULE_INIT type. The SYS_MODULE_OBJ returned by this function call
     * is passed to the driver tasks routine. DRV_USBHS_INDEX_0 is helper
     * constant defined in drv_usbfs.h */</span></i>

    usbDriverObj = DRV_USBHS_Initialize(DRV_USBHS_INDEX_0, (SYS_MODULE_INIT *)(drvUSBInit));
}

<strong><span style="color: #000080">void</span></strong> SYS_Tasks(<strong><span style="color: #000080">void</span></strong>)
{
    <i><span style="color: #008000">/* The polled state of the USB driver is updated by calling the
     * DRV_USBHS_Tasks function in the SYS_Tasks() function. The
     * DRV_USBHS_Tasks takes the driver module object returned by the
     * DRV_USBHS_Initialize funciton as a parameter. */</span></i>

    DRV_USBHS_Tasks(usbDriverObj);
}

<strong><span style="color: #000080">void</span></strong> __ISR( _USB_VECTOR , IPL4AUTO)_IntHandler_USB_stub ( <strong><span style="color: #000080">void</span></strong> )
{
    <i><span style="color: #008000">/* The DRV_USBHS_Tasks_ISR function updates the interrupt state of the USB
     * Driver. If the driver is configured for polling mode, this function need
     * not be invoked or included in the project. */</span></i>

    DRV_USBHS_Tasks_ISR(usbDriverObj);
}

<strong><span style="color: #000080">void</span></strong> __ISR ( _USB_DMA_VECTOR, IPL4AUTO)  _IntHandlerUSBInstance0_USBDMA ( <strong><span style="color: #000080">void</span></strong> )
{
    <i><span style="color: #008000">/* The DRV_USBHS_Tasks_ISR_USBDMA function update the DMA transfer state of
     * the USB Driver. */</span></i>

     DRV_USBHS_Tasks_ISR_USBDMA(usbDriverObj);
}</pre></div></div>
<p class="Element10">
The PIC32MX USB Driver requires definition of configuration constants to be available in the <span class="Element146">system_config.h</span> file of the MPLAB Harmony Application Project Configuration. Refer to the <a href="08926.html">Configuring the Library</a> section for details.</p><div class="Element15">
Multi-client Operation</div>
<p class="Element10">
The PIC32MZ USB Driver supports multi-client operation. In that, it can be opened by two application clients. This is required where Dual Operation is desired. The following should be noted when using multi-client operation:
<ul class="Element636">
<li class="Element606">The driver should be initialized for Dual Role Operation mode.</li>
<li class="Element606">The <a href="11692.html">DRV_USBHS_Open</a> function can be called at the most twice in the application. The driver supports a maximum of two clients.</li>
<li class="Element606">A client can access either the host or device functionality of the driver. It cannot do both.</li>
<li class="Element606">It is possible for the two clients to operate in two different threads while operating with an RTOS.</li>
</ul></p><div class="Element63">
<div class="TableDiv">
<table cellspacing="0" class="Table0">
<tr>
<td class="Element67" valign="top" width="10%" style="border:none;">
<div class="Element68">
<img src="Note Icon.png" border="0" alt="" title=""> <strong>Note:</strong>&nbsp;</div></td><td class="Element67" valign="top" width="90%" style="border:none;">
<div class="Element68">
The typical the application clients for PIC32MZ USB Driver would be the MPLAB Harmony USB Host and Device Stack. The complexity of operating the driver in Dual Role mode is handled by the stack operation. The MHC will configure the driver for Dual Role operation when such operation is selected in USB Stack configuration tree.&nbsp;</div></td></tr></table></div></div>
<div class="Element15">
USB Driver Common Interface</div>
<p class="Element10">
The PIC32MZ USB Driver exports its implementation of the USB Driver Common Interface to the Host and Device Layer via the <a href="11652.html">DRV_USBHS_HOST_INTERFACE</a> and <a href="11628.html">DRV_USBHS_DEVICE_INTERFACE</a> structures. The <a href="11652.html">DRV_USBHS_HOST_INTERFACE</a> structure is defined in the <span class="Element146">drv_usbhs_host.c</span> file. The following code example shows this structure. </p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code01132');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code01132"><pre class="Element12"><i><span style="color: #008000">/**********************************************************
 * This structure is a set of pointer to the USBHS driver
 * functions. It is provided to the host and device layer
 * as the interface to the driver.
 * *******************************************************/</span></i>

DRV_USB_HOST_INTERFACE gDrvUSBHSHostInterface =
{
    .open = DRV_USBHS_Open,
    .close = DRV_USBHS_Close,
    .eventHandlerSet = DRV_USBHS_ClientEventCallBackSet,
    .hostIRPSubmit = DRV_USBHS_HOST_IRPSubmit,
    .hostIRPCancel = DRV_USBHS_HOST_IRPCancel,
    .hostPipeSetup = DRV_USBHS_HOST_PipeSetup,
    .hostPipeClose = DRV_USBHS_HOST_PipeClose,
    .hostEventsDisable = DRV_USBHS_HOST_EventsDisable,
    .hostEventsEnable = DRV_USBHS_HOST_EventsEnable,
    .rootHubInterface.rootHubPortInterface.hubPortReset = DRV_USBHS_HOST_ROOT_HUB_PortReset,
    .rootHubInterface.rootHubPortInterface.hubPortSpeedGet = DRV_USBHS_HOST_ROOT_HUB_PortSpeedGet,
    .rootHubInterface.rootHubPortInterface.hubPortResetIsComplete = DRV_USBHS_HOST_ROOT_HUB_PortResetIsComplete,
    .rootHubInterface.rootHubPortInterface.hubPortSuspend = DRV_USBHS_HOST_ROOT_HUB_PortSuspend,
    .rootHubInterface.rootHubPortInterface.hubPortResume = DRV_USBHS_HOST_ROOT_HUB_PortResume,
    .rootHubInterface.rootHubMaxCurrentGet = DRV_USBHS_HOST_ROOT_HUB_MaximumCurrentGet,
    .rootHubInterface.rootHubPortNumbersGet = DRV_USBHS_HOST_ROOT_HUB_PortNumbersGet,
    .rootHubInterface.rootHubSpeedGet = DRV_USBHS_HOST_ROOT_HUB_BusSpeedGet,
    .rootHubInterface.rootHubInitialize = DRV_USBHS_HOST_ROOT_HUB_Initialize,
    .rootHubInterface.rootHubOperationEnable = DRV_USBHS_HOST_ROOT_HUB_OperationEnable,
    .rootHubInterface.rootHubOperationIsEnabled = DRV_USBHS_HOST_ROOT_HUB_OperationIsEnabled,
};</pre></div></div>
<p class="Element10">
The <a href="11538.html">DRV_USBFS_DEVICE_INTERFACE</a> structure is defined in the <span class="Element146">drv_usbhs_device.c</span> file. The following code example shows this structure.&nbsp;</p>
<p class="Element10">
The MPLAB Harmony USB Host and Device stack perform driver independent access through the function pointers contained in these structures. </p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code01133');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code01133"><pre class="Element12"><i><span style="color: #008000">/*****************************************************
 * This structure is a pointer to a set of USB Driver
 * Device mode functions. This set is exported to the
 * device layer when the device layer must use the
 * PIC32MZ USB Controller.
 ******************************************************/</span></i>

DRV_USB_DEVICE_INTERFACE gDrvUSBHSDeviceInterface =
{
    .open = DRV_USBHS_Open,
    .close = DRV_USBHS_Close,
    .eventHandlerSet = DRV_USBHS_ClientEventCallBackSet,
    .deviceAddressSet = DRV_USBHS_DEVICE_AddressSet,
    .deviceCurrentSpeedGet = DRV_USBHS_DEVICE_CurrentSpeedGet,
    .deviceSOFNumberGet = DRV_USBHS_DEVICE_SOFNumberGet,
    .deviceAttach = DRV_USBHS_DEVICE_Attach,
    .deviceDetach = DRV_USBHS_DEVICE_Detach,
    .deviceEndpointEnable = DRV_USBHS_DEVICE_EndpointEnable,
    .deviceEndpointDisable = DRV_USBHS_DEVICE_EndpointDisable,
    .deviceEndpointStall = DRV_USBHS_DEVICE_EndpointStall,
    .deviceEndpointStallClear = DRV_USBHS_DEVICE_EndpointStallClear,
    .deviceEndpointIsEnabled = DRV_USBHS_DEVICE_EndpointIsEnabled,
    .deviceEndpointIsStalled = DRV_USBHS_DEVICE_EndpointIsStalled,
    .deviceIRPSubmit = DRV_USBHS_DEVICE_IRPSubmit,
    .deviceIRPCancelAll = DRV_USBHS_DEVICE_IRPCancelAll,
    .deviceRemoteWakeupStop = DRV_USBHS_DEVICE_RemoteWakeupStop,
    .deviceRemoteWakeupStart = DRV_USBHS_DEVICE_RemoteWakeupStart,
    .deviceTestModeEnter = DRV_USBHS_DEVICE_TestModeEnter


};</pre></div></div>
<div class="Element15">
Operation with RTOS</div>
<p class="Element10">
The PIC32MZ USB Driver is designed to operate with a RTOS. The driver implementation uses the MPLAB Harmony Operating System Abstraction Layer (OSAL). This allows the driver to function with entire range of RTOSes supported in MPLAB Harmony. The following points must be considered while using the driver with an RTOS.
<ul class="Element636">
<li class="Element606">The driver can be opened from different threads</li>
<li class="Element606">In Device mode, an enabled endpoint should only be accessed from one thread. For example, if an application requires two endpoints, Endpoint 2 and Endpoint 3, the application could contain two threads, one accessing Endpoint 2 and another accessing Endpoint 3. The thread accessing Endpoint 2 cannot access Endpoint 3.</li>
<li class="Element606">While operating in Host mode, endpoint pipes can be opened from different threads. A pipe handle to an open pipe cannot be shared across threads.</li>
</ul></p><div class="Element15">
USB DMA Operation</div>
<p class="Element10">
The PIC32MZ USB module features a built-in DMA controller. This controller works independently of the PIC32MZ DMA controller. The PIC32MZ USB Driver uses USB DMA controller to expedite transfer of memory from the USB module FIFO to user application memory. The following should be noted for the USB DMA controller:
<ul class="Element636">
<li class="Element606">If the PIC32MZ USB Driver could not allocate a DMA channel (all channels are busy), it will use the CPU instructions to unload the endpoint FIFOs</li>
<li class="Element606">The USB module and the USB DMA controller interrupt priorities should be the same</li>
<li class="Element606">The application buffer start address should always be aligned on a 16-byte boundary and should be placed in coherent memory. Refer to the description of the <a href="11654.html">DRV_USBHS_HOST_IRPSubmit</a> and <a href="11631.html">DRV_USBHS_DEVICE_IRPSubmit</a> functions for details on how the user application buffer should be allocated.</li>
</ul></p><div class="Element15">
Root Hub Operation</div>
<p class="Element10">
The PIC32MZ USB Driver implements a Root Hub Driver Interface. This allows the driver to emulate a hub. The USB Host Stack enumerates the Root Hub as a device. The Host Stack then does not differentiate between an external hub and the root hub. While emulating a hub, the PIC32MZ USB Driver Root Hub appears as a single port hub.&nbsp;</p>
<p class="Element10">
As a part of the Root Hub interface, the PIC32MZ USB Driver requires the application to supply functions for hub features that it does not implement. These features are:
<ul class="Element636">
<li class="Element606">Port Overcurrent Detect</li>
<li class="Element606">VBUS Switch Control</li>
<li class="Element606">Port Indication</li>
</ul>A pointer to these functions (if implemented) must be supplied through the driver initialization data (of the type <a href="11675.html">DRV_USBHS_INIT</a>) structure at the time of driver initialization. The application has the option of not implementing these functions. In such a case, the function pointers for the unimplemented function, in the initialization data structure should be set to NULL.&nbsp;</p>
<p class="Element10">
The root hub driver must also be able to communicate the maximum current capability of its port to the USB Host Layer. The PIC32MZ USB Controller does not contain built-in (hardware implemented) functionality for controlling the root hub port current. To facilitate this request, the driver will report the current capability that was specified in the <span class="Element146">rootHubAvailableCurrent</span> parameter of the driver initialization data structure. The application must set this parameter to report the current supply capability of the VBUS power supply. The USB Host Layer uses this value to manage the bus current budget. If a connected device reports a configuration that requires more current than what the VBUS power supply can provide, the host will not set the configuration.</p><div class="Element15">
Port Overcurrent Detect</div>
<p class="Element10">
The Root Hub operation in PIC32MZ USB Driver will periodically call a Port Overcurrent Detect function to detect if an overcurrent condition is active on the port. The application must supply this function if port overcurrent detection is needed. The PIC32MZ USB Controller does not contain built-in (hardware implemented) functionality for checking overcurrent condition. The overcurrent condition on the port can occur in a case where the attached device has malfunctioned or when the USB VBUS line has short circuited to ground.&nbsp;</p>
<p class="Element10">
The signature of the function and an example implementation is shown in the following code example. The function must return (and must continue to return) true if an overcurrent condition exists on the port. </p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code01134');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code01134"><pre class="Element12"><i><span style="color: #008000">/* This code shows an example implementation of the
 * portOverCurrentDetect function. The PIC32MZ USB Driver will call this
 * function periodically to check if an over current condition exists on the
 * port. In this example, we assume that the over current detect pin from an
 * external circuit in the system, is connected to  port RD0 and the pin logic
 * is active high. The function must return true if an over current condition is
 * present on this pin */</span></i>


<strong><span style="color: #000080">bool</span></strong> BSP_USBVBUSSwitchOverCurrentDetect(uint8_t port)
{
    <strong><span style="color: #000080">if</span></strong>(PLIB_PORTS_PinGet(PORTS_ID_0, PORT_CHANNEL_D, 0) == 1)
    {
        <strong><span style="color: #000080">return</span></strong>(<strong><span style="color: #000080">true</span></strong>);
    }
    <strong><span style="color: #000080">else</span></strong>
    {
        <strong><span style="color: #000080">return</span></strong>(<strong><span style="color: #000080">false</span></strong>);
    }
}</pre></div></div>
<div class="Element15">
VBUS Switch Control</div>
<p class="Element10">
The PIC32MZ USB Driver Root Hub operation will attempt to control the VBUS power supply to the port. Because the PIC32MZ USB Controller does not contain built-in (hardware implemented) functionality for checking controlling VBUS, such a control function must be supplied by the application. The root hub operation will access this function when the PIC32MX USB Driver will call the portPowerEnable function as a part of the Bus Enable sequence.&nbsp;</p>
<p class="Element10">
The following code shows an example of how this function can be implemented. </p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code01135');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code01135"><pre class="Element12"><i><span style="color: #008000">/* This code shows an example implementation of the VBUS Power Enable
 * function. The PIC32MZ USB Driver will call this function as a part of bus
 * enable function. In this example, it is assumed that system contains an
 * external VBUS power switch and this is control by port RB5.
 */</span></i>

<strong><span style="color: #000080">void</span></strong> BSP_USBVBUSPowerEnable(uint8_t port, <strong><span style="color: #000080">bool</span></strong> enable)
{
    <strong><span style="color: #000080">if</span></strong>(enable)
    {
        PLIB_PORTS_PinSet(PORTS_ID_0, PORT_CHANNEL_B, PORTS_BIT_POS_5);
    }
    <strong><span style="color: #000080">else</span></strong>
    {
        PLIB_PORTS_PinClear(PORTS_ID_0, PORT_CHANNEL_B, PORTS_BIT_POS_5);
    }
}</pre></div></div>
<div class="Element15">
Port Indication Function</div>
<p class="Element10">
The Root Hub Operation in the PIC32MZ USB Driver allows display of Port LED status. If the application requires this indication, it must implement a function which the Root Hub operation would call when a change in the Root Hub port has occurred. The port indication operation is specified in Section 11.5.3 of the USB 2.0 Specification. </p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code01136');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code01136"><pre class="Element12"><i><span style="color: #008000">/* This code shows an example implementation of the port indication
 * function. The PIC32MZ USB Driver call this function when it wants to indicate
 * port status. It is assumed that three function to switch off, blink and
 * switch on an LED are available. It is further assumed that these function
 * accept the color of the LED to operated on. */</span></i>

<strong><span style="color: #000080">void</span></strong> BSP_RootHubPortIndication
(
    uint8_t port,
    USB_HUB_PORT_INDICATOR_COLOR color,
    USB_HUB_PORT_INDICATOR_STATE state
)
{
    <i><span style="color: #008000">/* The color parameter indicates the color of the LED to be affected. The
     * color will be either USB_HUB_PORT_INDICATOR_COLOR_GREEN or
     * USB_HUB_PORT_INDICATOR_COLOR_AMBER. */</span></i>

    <strong><span style="color: #000080">switch</span></strong> (state)
    {
        <strong><span style="color: #000080">case</span></strong> USB_HUB_PORT_INDICATOR_STATE_OFF:
            BSP_SwitchLEDOff(color);
            <strong><span style="color: #000080">break</span></strong>;
        <strong><span style="color: #000080">case</span></strong> USB_HUB_PORT_INDICATOR_STATE_BLINKING:
            BSP_LEDBlink(color);
            <strong><span style="color: #000080">break</span></strong>;
        <strong><span style="color: #000080">case</span></strong> USB_HUB_PORT_INDICATOR_STATE_ON:
            BSP_SwitchLEDOn(color);
            <strong><span style="color: #000080">break</span></strong>;
        <strong><span style="color: #000080">default</span></strong>:
            <strong><span style="color: #000080">break</span></strong>;
    }
}</pre></div></div>
</div>
</div>
</div>
<!-- End Page Content -->

<!-- Begin Page Footer -->
<div class="Element95">
<a href="16811.html">Volume V: MPLAB Harmony Framework Reference</a> &gt; <a href="13069.html">Driver Libraries Help</a> &gt; <a href="28590.html">USB Driver Libraries</a> &gt; <a href="08950.html">PIC32MZ USB Driver</a> &gt; <a href="08951.html">Using the Library</a> &gt; <a href="08945.html">How the Library Works</a></div>
<div class="Element93">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="100%">
<div class="Element3">
 MPLAB Harmony Help</div>
</td></tr><tr><td width="100%">
<div class="Element4">
<a href="contents.htm">Contents</a> | <a href="idx.html">Index</a> | <a href="04300.html">Home</a></div>
</td></tr><tr><td width="100%">
<div class="Element97">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: DRV USB PIC32MZ How the Library Works Topic Title: How the Library Works)&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com">Microchip Support</a></div>
</td></tr></table></div>

<!-- End Page Footer -->
</div>
</div>

<!-- End Client Area -->
</body></html>