<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Implementing Multiple Client Drivers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="generator" content="Doc-O-Matic" />
    <meta name="save" content="history" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <link rel="STYLESHEET" href="default.css" type="text/css" />

<script type="text/javascript" src="scripts.js"></script>
</head>
<body class="Element700" onload="onBodyLoad();" onmousedown="onBodyMouseDown();">
<div id="persistenceDiv" style="display:none; behavior:url(#default#userData);"></div>

<!-- Begin Popups -->

<!-- End Popups -->

<!-- Begin Page Header -->
<div class="Element710" id="areafixed">
<div class="Element94">
<a href="13064.html">Volume IV: MPLAB Harmony Development</a> &gt; <a href="16810.html">MPLAB Harmony Driver Development Guide</a> &gt; <a href="11782.html">Implementing Multiple Client Drivers</a></div>
<div class="Element92">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="25%">
<div class="Element1">
MPLAB Harmony Help</div>
</td><td width="25%">
<div class="Element2">
<a href="contents.htm">Contents</a> | <a href="idx.html">Index</a> | <a href="04300.html">Home</a></div>
</td><td width="25%">
<div class="Element90">
<a href="11794.html">Previous</a> | <a href="16810.html">Up</a> | <a href="11801.html">Next</a></div>
</td><td width="25%">
<div class="Element96">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: DRVDEVGUIDE Implementing Multiple Client Drivers Topic Title: Implementing Multiple Client Drivers)&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com">Microchip Support</a></div>
</td></tr></table><div class="Element5">
Implementing Multiple Client Drivers</div>
</div>
</div>

<!-- End Page Header -->

<!-- Begin Client Area -->
<div class="Element720" id="areascroll">
<div class="Element721">

<!-- Begin Page Content -->
<div class="Element58">
<a name="4465736372697074696F6E"></a><div class="Element11">
<div class="Element10">
<p class="Element10">
When the concept of managing multiple clients is combined with the concept of managing multiple instances, the full picture of a MPLAB Harmony driver emerges, as shown in the following diagram. See <a href="11799.html">Single Client vs. Multiple Client</a> and <a href="11781.html">Implementation vs. Instances</a> for more information. </p><p class="Element10" style="text-align: center;">
<img src="DRVDEVGUIDE Multiple Client Drivers Diagram.png" border="0" alt="" title=""></p><p class="Element10">
One method of implementing the ability to manage multiple instances of the peripheral hardware and multiple independent clients within the same driver is described in the following diagram, using the familiar USART as an example. Other methods may be possible, but this example illustrates the requirement. </p><p class="Element10" style="text-align: center;">
<img src="DRVDEVGUIDE Multiple Client Drivers USART Diagram.png" border="0" alt="" title=""></p><p class="Element10">
The diagram shows the definitions of two data structures. The DRV_USART_OBJ structure is used to store all of the data required to manage a single instance of the peripheral hardware. (This structure is described in the <a href="11781.html">Implementation vs. Instances</a> section.) The DRV_USART_CLIENT_OBJ structure stores all of the data required to keep track of an individual client.&nbsp;</p>
<p class="Element10">
Since the driver manages multiple instances of the peripheral, there will be one instance of the DRV_USART_OBJ structure per peripheral instance, as defined by the <a href="11494.html">DRV_USART_INSTANCES_NUMBER</a> configuration parameter and allocated by the <span class="Element146">drvUsart</span> array shown previously. Since the driver manages multiple clients, there will also be a number of client data structures, as defined by the <a href="11486.html">DRV_USART_CLIENTS_NUMBER</a> configuration parameter and allocated by the <span class="Element146">drvUsartClient</span> array. One structure form the array will be assigned to each client that calls the driver’s open function until they are all allocated.&nbsp;</p>
<p class="Element10">
One item of particular importance in the client object structure is the pointer that associates a client with the driver instance. This pointer (and usually other data) will be initialized when a client calls the driver’s open function. The following example shows a possible implementation of this function (assuming the previous structure definitions).&nbsp;</p>
<p class="Element10">
<strong>Example: Driver Open Function</strong> &nbsp;</p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code00166');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code00166"><pre class="Element12">DRV_HANDLE DRV_USART_Open( <strong><span style="color: #000080">const</span></strong> SYS_MODULE_INDEX index,
                           <strong><span style="color: #000080">const</span></strong> DRV_IO_INTENT    ioIntent )
{
    <strong><span style="color: #000080">int</span></strong> i;
    DRV_USART_CLIENT_OBJ pClient = (DRV_USART_CLIENT_OBJ *)DRV_HANDLE_INVALID;

    <strong><span style="color: #000080">for</span></strong> (i=0; i &lt; DRV_USART_CLIENTS_NUMBER; i++)
    {
        <strong><span style="color: #000080">if</span></strong> (drvUsartClient[i].driver == NULL)
        {
            pClient = &amp;drvUsartClient[i];
            pClient-&gt;driver = &amp;drvUsart[index];
            <strong><span style="color: #000080">break</span></strong>;
        }
    }

    <strong><span style="color: #000080">return</span></strong> (DRV_HANDLE)pClient;
}</pre></div></div>
<p class="Element10">
This implementation of the <a href="11502.html">DRV_USART_Open</a> function does a linear search through the array of client objects. The first one it finds with a NULL driver pointer is assumed to be unallocated and available for use. It then assigns the address of the driver object structure in the <span class="Element146">drvUsart</span> array that is identified by the function’s index parameter. Doing this simultaneously allocates that client object and associates it with the specified driver instance. An open function would normally store some additional data and maybe do some other preparation to get ready to service the client, but this simple example shows how a unique opened driver handle can be created that identifies a client, how a client object structure might provide a storage location for client-specific data, and how the driver can associate the handle with a specific instance of the driver and peripheral. </p><div class="Element63">
<div class="TableDiv">
<table cellspacing="0" class="Table0">
<tr>
<td class="Element67" valign="top" width="10%" style="border:none;">
<div class="Element68">
<img src="Note Icon.png" border="0" alt="" title=""> <strong>Note:</strong>&nbsp;</div></td><td class="Element67" valign="top" width="90%" style="border:none;">
<div class="Element68">
This example is not RTOS safe. A RTOS safe implementation would protect the for loop with a mutex. Refer to the <a href="11784.html">Interrupt and Thread Safety</a> section for more in formation on RTOS safety.&nbsp;</div></td></tr></table></div></div>
<p class="Element10">
Once the driver has been opened and the association between the client and the driver instance has been made, the driver handle can be returned to the client and then later be used by other client interface functions to interact with the peripheral safely, as shown in the following example.&nbsp;</p>
<p class="Element10">
<strong>Example: Client API Function Implementation</strong> &nbsp;</p><div class="Element170">
<a href="#" onclick="CopyElementToClipboard('code00167');">Copy Code</a></div>
<div class="Element13"><div class="Element12" id="code00167"><pre class="Element12"><strong><span style="color: #000080">void</span></strong> DRV_USART_BufferAddRead ( <strong><span style="color: #000080">const</span></strong> DRV_HANDLE handle,
                               DRV_USART_BUFFER_HANDLE * <strong><span style="color: #000080">const</span></strong> bufferHandle,
                               <strong><span style="color: #000080">void</span></strong> * buffer, <strong><span style="color: #000080">const</span></strong> size_t size )
{
    DRV_USART_CLIENT_OBJ *client = (DRV_USART_CLIENT_OBJ *)handle;
    DRV_USART_OBJ        *driver = (DRV_USART_OBJ *)client-&gt;driver;

    <strong><span style="color: #000080">if</span></strong> (driver-&gt;buffer == NULL)
    {
        driver-&gt;buffer       = buffer;
        driver-&gt;bufferSize   = size;
        bufferHandle         = buffer;

        <i><span style="color: #008000">/* Start the data transfer process. */</span></i>

    }
    <strong><span style="color: #000080">else</span></strong>
    {
        *bufferHandle = DRV_USART_BUFFER_HANDLE_INVALID;
    }

    <strong><span style="color: #000080">return</span></strong>;
}</pre></div></div>
<p class="Element10">
This example shows how a buffer queuing read might work. However, it is somewhat oversimplified because it only maintains a queue size of one. This is because the driver structure only keeps a single buffer pointer and <span class="Element146">bufferSize</span> variable (instead of a queue of several of them). So, in this example, the driver checks to see if its buffer pointer is NULL (which, presumably, that is how it was initialized during the driver’s initialize function and how it is reset whenever a transfer completes). However, if the buffer pointer is not NULL, it means that the driver is currently busy transferring a previous request. This causes the driver to return an invalid buffer handle value (DRV_USART_BUFFER_HANDLE_INVALID) to the caller. When this happens, the client calling will have to try again later because the queue (of one entry) is full. If the buffer pointer is NULL, it is not in use (i.e., the queue is not full) and the function will save the caller’s buffer pointer and size information and do whatever is necessary to start the data transfer, likely interacting with the hardware through the peripheral library at that point.&nbsp;</p>
<p class="Element10">
While this example is incomplete and somewhat limited, it does demonstrate how a client API function might use the opened driver handle to identify the link to the peripheral instance and prevent conflicts between peripherals. In this case, a rather brute force method of only allowing a single transfer to occur at a time is used; but, that method is completely valid as regardless of how big the queue is, it can always become full. However, more sophisticated methods (such as implementing an actual transfer queue) would let the driver provide better throughput.</p></div>
</div>
</div>
<!-- End Page Content -->

<!-- Begin Page Footer -->
<div class="Element95">
<a href="13064.html">Volume IV: MPLAB Harmony Development</a> &gt; <a href="16810.html">MPLAB Harmony Driver Development Guide</a> &gt; <a href="11782.html">Implementing Multiple Client Drivers</a></div>
<div class="Element93">
<table width="100%" cellspacing="0" cellpadding="0">
<tr><td width="100%">
<div class="Element3">
 MPLAB Harmony Help</div>
</td></tr><tr><td width="100%">
<div class="Element4">
<a href="contents.htm">Contents</a> | <a href="idx.html">Index</a> | <a href="04300.html">Home</a></div>
</td></tr><tr><td width="100%">
<div class="Element97">
<a href="mailto:docerrors@microchip.com&subject=MPLAB Harmony Documentation Feedback (Topic ID: DRVDEVGUIDE Implementing Multiple Client Drivers Topic Title: Implementing Multiple Client Drivers)&body=Thank you for your feedback! Please include a description of your feedback, and indicate whether you are reporting an an error in the documentation or an enhancement.">Documentation Feedback</a><br> <a href="http://support.microchip.com">Microchip Support</a></div>
</td></tr></table></div>

<!-- End Page Footer -->
</div>
</div>

<!-- End Client Area -->
</body></html>